// Hollywood Connman Control Library
// (C) 2021, 2022 Originull Software
// This class is based on CMST
// Copyright (C) 2013-2022 Andrew J. Bibb
// SPDX-License-Identifier: MIT

# include <QtCore/QDebug>
# include <QtDBus/QDBusConnection>
# include <QMessageBox>
# include <QDialog>
# include <QFile>
# include <QTextStream>

#include "agent.h"
#include "private/agent_p.h"
#include "private/wifi_dialog_p.h"
//header files generated by qmake from the xml file created by qdbuscpp2xml
#include "netagent_adaptor.h"
#include "netagent_interface.h"

//  defines
#define ERROR_RETRY "net.connman.Agent.Error.Retry"
#define ERROR_CANCELED "net.connman.Agent.Error.Canceled"
#define ERROR_LAUNCHBROWSER "net.connman.Agent.Error.LaunchBrowser"

namespace HWCM
{
ConnmanAgentPrivate::ConnmanAgentPrivate(ConnmanAgent *q)
    : m_q(q)
{
    // members
    m_wifi = new WifiDialog(0);
    input_map.clear();
    b_loginputrequest = false;
}

//  Function to put all of input fields received via DBus:RequestInput into a
//  QMap<QString,QString> where key is the input field received and value is
//  generally blank but can be used for informational text.
//
//  If we asked to log the input request create the log file in /tmp/cmst/input_request.log
void ConnmanAgentPrivate::createInputMap(const QMap<QString,QVariant>& r_map)
{
  // Initialize our data map
  input_map.clear();

  // QFile object for logging
  QTextStream log;
  QDir d(IPT_REQ_LOG_PATH);
  QFile logfile(d.absoluteFilePath(IPT_REQ_LOG_FILE));
  if (b_loginputrequest) {
    if (!logfile.open(QIODevice::WriteOnly | QIODevice::Text)) b_loginputrequest = false;
    else log.setDevice(&logfile);
  }


  // Run through the r_map getting the keys and the few values we are interested in.
  QMap<QString, QVariant>::const_iterator i = r_map.constBegin();
  while (i != r_map.constEnd()) {

    // Lets see what the values contain, but first make sure we can get to them.
    if (b_loginputrequest) log << "Agent: " << "Map Key = " << i.key() << "\n";

    if (! i.value().canConvert<QDBusArgument>() ) return;
    const QDBusArgument qdba =  i.value().value<QDBusArgument>();
    if (qdba.currentType() != QDBusArgument::MapType ) {
      if (b_loginputrequest) log << "Agent: " << "Error - QDBusArgument as the value is not a MapType\n";
      return;
    }

    // The r_map.value() is a QDBusArgument::MapType so extract this map into a new QMap called m.
    qdba.beginMap();
    QMap<QString,QString> m;
    m.clear();
    if (b_loginputrequest) log << "Agent: " << "Extracting the DBusArgument Map...\n";
    while ( ! qdba.atEnd() ) {
      QString k;
      QVariant v;
      qdba.beginMapEntry();
      qdba >> k >> v;
      qdba.endMapEntry();
      m.insert(k, v.toString());
      if (b_loginputrequest) log << "{ " << k << " , " << v.toString() << "}\n";
    } // while
    qdba.endMap();

    // Browse through QMap m and get things we need to look at
    // Types we don' really care about.  We ignore "optional" and "alternate" requirements
    // and only extract the "mandatory" and "informational" requirements with values
    if (m.contains("Requirement") ) {
      QString val = QString();
      if ( m.value("Requirement").contains("mandatory", Qt::CaseInsensitive) || m.value("Requirement").contains("informational", Qt::CaseInsensitive) ) {
        if (m.contains("Value") ) val = m.value("Value");
      } // if mandatory or informational
      //  create our input_map entry
      input_map[i.key()] = val;
    } // if requirement

    ++i;
  } // while

  logfile.close();
  return;
}

//  constructor
ConnmanAgent::ConnmanAgent(QObject* parent)
    : QObject(parent),
      m_d(new ConnmanAgentPrivate(this))
{ 
  //  Create Adaptor and register this Agent on the system bus.  
  new AgentAdaptor(this);
  QDBusConnection::systemBus().registerObject(AGENT_OBJECT, this);
  
}

void ConnmanAgent::setLogInputRequest(bool b)
{
    m_d->b_loginputrequest = b;
}

// Called when the service daemon unregisters the agent.  QT deals with cleanup
// tasks so don't need much here
void ConnmanAgent::Release()
{
  //qDebug() << "Agent Released";
  return;
}

// Called when an error has to be reported to the user.  Show the
// error in a QMessageBox
void ConnmanAgent::ReportError(QDBusObjectPath path, QString s_error)
{
  (void) path;
  
  if ( QMessageBox::warning(qobject_cast<QWidget *> (parent()), tr("Connman Error"),
    tr("Connman returned the following error:<b><center>%1</b><br>Would you like to retry?").arg(s_error),
    QMessageBox::Yes | QMessageBox::No,
    QMessageBox::No
     ) == QMessageBox::Yes) sendErrorReply(ERROR_RETRY, "Going to retry the request");
  
  else  return; 
}

//
// Called when it is required to ask the user to open a website to proceed
// with login handling
void ConnmanAgent::RequestBrowser(QDBusObjectPath path, QString url)
{
    Q_UNUSED(path);

    return;
}

//
// Called when trying to connect to a service and some extra input is required from the user
// A dialog is displayed with the required fields enabled (non-required fields are disabled).
QVariantMap ConnmanAgent::RequestInput(QDBusObjectPath path, QMap<QString,QVariant> dict)
{
    Q_UNUSED(path);
    qDebug() << "RequestInput";
  
    // Take the dict returned by DBus and extract the information we are interested in and place in input_map.
    m_d->createInputMap(dict);

    // Send our input_map to the dialog to have the user supply the necessary information
    // needed to continue.  Return if canceled.
    QMap<QString,QVariant> rtn;
    rtn.clear();
    if (m_d->m_wifi->showWithMap(m_d->input_map) == QDialog::Rejected)
        sendErrorReply(ERROR_CANCELED,"User cancelled the dialog");
    else
    m_d->m_wifi->createDict(rtn);  // create a return dict and send it back to connman on DBus

    return rtn;
}

//
// Called when the agent request failed before a reply was returned. Show
// a QMessageBox
void ConnmanAgent::Cancel()
{
  QMessageBox::information(qobject_cast<QWidget *> (parent()), tr("Agent Request Failed"),
    tr("The agent request failed before a reply was returned.") );    
    
  return;
}

} // END namespace HWCM
