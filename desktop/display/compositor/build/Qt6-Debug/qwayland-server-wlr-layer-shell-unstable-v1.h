// This file was generated by qtwaylandscanner
// source file is wlr-layer-shell-unstable-v1.xml

#ifndef QT_WAYLAND_SERVER_WLR_LAYER_SHELL_UNSTABLE_V1
#define QT_WAYLAND_SERVER_WLR_LAYER_SHELL_UNSTABLE_V1

#include "wayland-server-core.h"
#include "wayland-wlr-layer-shell-unstable-v1-server-protocol.h"
#include <QByteArray>
#include <QMultiMap>
#include <QString>

#ifndef WAYLAND_VERSION_CHECK
#define WAYLAND_VERSION_CHECK(major, minor, micro) \
    ((WAYLAND_VERSION_MAJOR > (major)) || \
    (WAYLAND_VERSION_MAJOR == (major) && WAYLAND_VERSION_MINOR > (minor)) || \
    (WAYLAND_VERSION_MAJOR == (major) && WAYLAND_VERSION_MINOR == (minor) && WAYLAND_VERSION_MICRO >= (micro)))
#endif

QT_BEGIN_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
QT_WARNING_DISABLE_CLANG("-Wmissing-field-initializers")

namespace QtWaylandServer {
    class  zwlr_layer_shell_v1
    {
    public:
        zwlr_layer_shell_v1(struct ::wl_client *client, uint32_t id, int version);
        zwlr_layer_shell_v1(struct ::wl_display *display, int version);
        zwlr_layer_shell_v1(struct ::wl_resource *resource);
        zwlr_layer_shell_v1();

        virtual ~zwlr_layer_shell_v1();

        class Resource
        {
        public:
            Resource() : zwlr_layer_shell_v1_object(nullptr), handle(nullptr) {}
            virtual ~Resource() {}

            zwlr_layer_shell_v1 *zwlr_layer_shell_v1_object;
            zwlr_layer_shell_v1 *object() { return zwlr_layer_shell_v1_object; } 
            struct ::wl_resource *handle;

            struct ::wl_client *client() const { return wl_resource_get_client(handle); }
            int version() const { return wl_resource_get_version(handle); }

            static Resource *fromResource(struct ::wl_resource *resource);
        };

        void init(struct ::wl_client *client, uint32_t id, int version);
        void init(struct ::wl_display *display, int version);
        void init(struct ::wl_resource *resource);

        Resource *add(struct ::wl_client *client, int version);
        Resource *add(struct ::wl_client *client, uint32_t id, int version);
        Resource *add(struct wl_list *resource_list, struct ::wl_client *client, uint32_t id, int version);

        Resource *resource() { return m_resource; }
        const Resource *resource() const { return m_resource; }

        QMultiMap<struct ::wl_client*, Resource*> resourceMap() { return m_resource_map; }
        const QMultiMap<struct ::wl_client*, Resource*> resourceMap() const { return m_resource_map; }

        bool isGlobal() const { return m_global != nullptr; }
        bool isResource() const { return m_resource != nullptr; }

        static const struct ::wl_interface *interface();
        static QByteArray interfaceName() { return interface()->name; }
        static int interfaceVersion() { return interface()->version; }


        enum error {
            error_role = 0, // wl_surface has another role
            error_invalid_layer = 1, // layer value is invalid
            error_already_constructed = 2, // wl_surface has a buffer attached or committed
        };

        enum layer {
            layer_background = 0,
            layer_bottom = 1,
            layer_top = 2,
            layer_overlay = 3,
        };

    protected:
        virtual Resource *zwlr_layer_shell_v1_allocate();

        virtual void zwlr_layer_shell_v1_bind_resource(Resource *resource);
        virtual void zwlr_layer_shell_v1_destroy_resource(Resource *resource);

        virtual void zwlr_layer_shell_v1_get_layer_surface(Resource *resource, uint32_t id, struct ::wl_resource *surface, struct ::wl_resource *output, uint32_t layer, const QString &l_namespace);
        virtual void zwlr_layer_shell_v1_destroy(Resource *resource);

    private:
        static void bind_func(struct ::wl_client *client, void *data, uint32_t version, uint32_t id);
        static void destroy_func(struct ::wl_resource *client_resource);
        static void display_destroy_func(struct ::wl_listener *listener, void *data);

        Resource *bind(struct ::wl_client *client, uint32_t id, int version);
        Resource *bind(struct ::wl_resource *handle);

        static const struct ::zwlr_layer_shell_v1_interface m_zwlr_layer_shell_v1_interface;

        static void handle_get_layer_surface(
            ::wl_client *client,
            struct wl_resource *resource,
            uint32_t id,
            struct ::wl_resource *surface,
            struct ::wl_resource *output,
            uint32_t layer,
            const char *l_namespace);
        static void handle_destroy(
            ::wl_client *client,
            struct wl_resource *resource);

        QMultiMap<struct ::wl_client*, Resource*> m_resource_map;
        Resource *m_resource;
        struct ::wl_global *m_global;
        struct DisplayDestroyedListener : ::wl_listener {
            zwlr_layer_shell_v1 *parent;
        };
        DisplayDestroyedListener m_displayDestroyedListener;
    };

    class  zwlr_layer_surface_v1
    {
    public:
        zwlr_layer_surface_v1(struct ::wl_client *client, uint32_t id, int version);
        zwlr_layer_surface_v1(struct ::wl_display *display, int version);
        zwlr_layer_surface_v1(struct ::wl_resource *resource);
        zwlr_layer_surface_v1();

        virtual ~zwlr_layer_surface_v1();

        class Resource
        {
        public:
            Resource() : zwlr_layer_surface_v1_object(nullptr), handle(nullptr) {}
            virtual ~Resource() {}

            zwlr_layer_surface_v1 *zwlr_layer_surface_v1_object;
            zwlr_layer_surface_v1 *object() { return zwlr_layer_surface_v1_object; } 
            struct ::wl_resource *handle;

            struct ::wl_client *client() const { return wl_resource_get_client(handle); }
            int version() const { return wl_resource_get_version(handle); }

            static Resource *fromResource(struct ::wl_resource *resource);
        };

        void init(struct ::wl_client *client, uint32_t id, int version);
        void init(struct ::wl_display *display, int version);
        void init(struct ::wl_resource *resource);

        Resource *add(struct ::wl_client *client, int version);
        Resource *add(struct ::wl_client *client, uint32_t id, int version);
        Resource *add(struct wl_list *resource_list, struct ::wl_client *client, uint32_t id, int version);

        Resource *resource() { return m_resource; }
        const Resource *resource() const { return m_resource; }

        QMultiMap<struct ::wl_client*, Resource*> resourceMap() { return m_resource_map; }
        const QMultiMap<struct ::wl_client*, Resource*> resourceMap() const { return m_resource_map; }

        bool isGlobal() const { return m_global != nullptr; }
        bool isResource() const { return m_resource != nullptr; }

        static const struct ::wl_interface *interface();
        static QByteArray interfaceName() { return interface()->name; }
        static int interfaceVersion() { return interface()->version; }


        enum keyboard_interactivity {
            keyboard_interactivity_none = 0,
            keyboard_interactivity_exclusive = 1,
            keyboard_interactivity_on_demand = 2,
        };

        enum error {
            error_invalid_surface_state = 0, // provided surface state is invalid
            error_invalid_size = 1, // size is invalid
            error_invalid_anchor = 2, // anchor bitfield is invalid
            error_invalid_keyboard_interactivity = 3, // keyboard interactivity is invalid
        };

        enum anchor {
            anchor_top = 1, // the top edge of the anchor rectangle
            anchor_bottom = 2, // the bottom edge of the anchor rectangle
            anchor_left = 4, // the left edge of the anchor rectangle
            anchor_right = 8, // the right edge of the anchor rectangle
        };

        void send_configure(uint32_t serial, uint32_t width, uint32_t height);
        void send_configure(struct ::wl_resource *resource, uint32_t serial, uint32_t width, uint32_t height);
        void send_closed();
        void send_closed(struct ::wl_resource *resource);

    protected:
        virtual Resource *zwlr_layer_surface_v1_allocate();

        virtual void zwlr_layer_surface_v1_bind_resource(Resource *resource);
        virtual void zwlr_layer_surface_v1_destroy_resource(Resource *resource);

        virtual void zwlr_layer_surface_v1_set_size(Resource *resource, uint32_t width, uint32_t height);
        virtual void zwlr_layer_surface_v1_set_anchor(Resource *resource, uint32_t anchor);
        virtual void zwlr_layer_surface_v1_set_exclusive_zone(Resource *resource, int32_t zone);
        virtual void zwlr_layer_surface_v1_set_margin(Resource *resource, int32_t top, int32_t right, int32_t bottom, int32_t left);
        virtual void zwlr_layer_surface_v1_set_keyboard_interactivity(Resource *resource, uint32_t keyboard_interactivity);
        virtual void zwlr_layer_surface_v1_get_popup(Resource *resource, struct ::wl_resource *popup);
        virtual void zwlr_layer_surface_v1_ack_configure(Resource *resource, uint32_t serial);
        virtual void zwlr_layer_surface_v1_destroy(Resource *resource);
        virtual void zwlr_layer_surface_v1_set_layer(Resource *resource, uint32_t layer);

    private:
        static void bind_func(struct ::wl_client *client, void *data, uint32_t version, uint32_t id);
        static void destroy_func(struct ::wl_resource *client_resource);
        static void display_destroy_func(struct ::wl_listener *listener, void *data);

        Resource *bind(struct ::wl_client *client, uint32_t id, int version);
        Resource *bind(struct ::wl_resource *handle);

        static const struct ::zwlr_layer_surface_v1_interface m_zwlr_layer_surface_v1_interface;

        static void handle_set_size(
            ::wl_client *client,
            struct wl_resource *resource,
            uint32_t width,
            uint32_t height);
        static void handle_set_anchor(
            ::wl_client *client,
            struct wl_resource *resource,
            uint32_t anchor);
        static void handle_set_exclusive_zone(
            ::wl_client *client,
            struct wl_resource *resource,
            int32_t zone);
        static void handle_set_margin(
            ::wl_client *client,
            struct wl_resource *resource,
            int32_t top,
            int32_t right,
            int32_t bottom,
            int32_t left);
        static void handle_set_keyboard_interactivity(
            ::wl_client *client,
            struct wl_resource *resource,
            uint32_t keyboard_interactivity);
        static void handle_get_popup(
            ::wl_client *client,
            struct wl_resource *resource,
            struct ::wl_resource *popup);
        static void handle_ack_configure(
            ::wl_client *client,
            struct wl_resource *resource,
            uint32_t serial);
        static void handle_destroy(
            ::wl_client *client,
            struct wl_resource *resource);
        static void handle_set_layer(
            ::wl_client *client,
            struct wl_resource *resource,
            uint32_t layer);

        QMultiMap<struct ::wl_client*, Resource*> m_resource_map;
        Resource *m_resource;
        struct ::wl_global *m_global;
        struct DisplayDestroyedListener : ::wl_listener {
            zwlr_layer_surface_v1 *parent;
        };
        DisplayDestroyedListener m_displayDestroyedListener;
    };
}

QT_WARNING_POP
QT_END_NAMESPACE

#endif
