// This file was generated by qtwaylandscanner
// source file is gtk.xml

#include "qwayland-server-gtk.h"

QT_BEGIN_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
QT_WARNING_DISABLE_CLANG("-Wmissing-field-initializers")

namespace QtWaylandServer {
    gtk_shell1::gtk_shell1(struct ::wl_client *client, uint32_t id, int version)
        : m_resource_map()
        , m_resource(nullptr)
        , m_global(nullptr)
    {
        init(client, id, version);
    }

    gtk_shell1::gtk_shell1(struct ::wl_display *display, int version)
        : m_resource_map()
        , m_resource(nullptr)
        , m_global(nullptr)
    {
        init(display, version);
    }

    gtk_shell1::gtk_shell1(struct ::wl_resource *resource)
        : m_resource_map()
        , m_resource(nullptr)
        , m_global(nullptr)
    {
        init(resource);
    }

    gtk_shell1::gtk_shell1()
        : m_resource_map()
        , m_resource(nullptr)
        , m_global(nullptr)
    {
    }

    gtk_shell1::~gtk_shell1()
    {
        for (auto resource : std::as_const(m_resource_map))
            resource->gtk_shell1_object = nullptr;

        if (m_resource)
            m_resource->gtk_shell1_object = nullptr;

        if (m_global) {
            wl_global_destroy(m_global);
            wl_list_remove(&m_displayDestroyedListener.link);
        }
    }

    void gtk_shell1::init(struct ::wl_client *client, uint32_t id, int version)
    {
        m_resource = bind(client, id, version);
    }

    void gtk_shell1::init(struct ::wl_resource *resource)
    {
        m_resource = bind(resource);
    }

    gtk_shell1::Resource *gtk_shell1::add(struct ::wl_client *client, int version)
    {
        Resource *resource = bind(client, 0, version);
        m_resource_map.insert(client, resource);
        return resource;
    }

    gtk_shell1::Resource *gtk_shell1::add(struct ::wl_client *client, uint32_t id, int version)
    {
        Resource *resource = bind(client, id, version);
        m_resource_map.insert(client, resource);
        return resource;
    }

    void gtk_shell1::init(struct ::wl_display *display, int version)
    {
        m_global = wl_global_create(display, &::gtk_shell1_interface, version, this, bind_func);
        m_displayDestroyedListener.notify = gtk_shell1::display_destroy_func;
        m_displayDestroyedListener.parent = this;
        wl_display_add_destroy_listener(display, &m_displayDestroyedListener);
    }

    const struct wl_interface *gtk_shell1::interface()
    {
        return &::gtk_shell1_interface;
    }

    gtk_shell1::Resource *gtk_shell1::gtk_shell1_allocate()
    {
        return new Resource;
    }

    void gtk_shell1::gtk_shell1_bind_resource(Resource *)
    {
    }

    void gtk_shell1::gtk_shell1_destroy_resource(Resource *)
    {
    }

    void gtk_shell1::bind_func(struct ::wl_client *client, void *data, uint32_t version, uint32_t id)
    {
        gtk_shell1 *that = static_cast<gtk_shell1 *>(data);
        that->add(client, id, version);
    }

    void gtk_shell1::display_destroy_func(struct ::wl_listener *listener, void *data)
    {
        Q_UNUSED(data);
        gtk_shell1 *that = static_cast<gtk_shell1::DisplayDestroyedListener *>(listener)->parent;
        that->m_global = nullptr;
    }

    void gtk_shell1::destroy_func(struct ::wl_resource *client_resource)
    {
        Resource *resource = Resource::fromResource(client_resource);
        Q_ASSERT(resource);
        gtk_shell1 *that = resource->gtk_shell1_object;
        if (Q_LIKELY(that)) {
            that->m_resource_map.remove(resource->client(), resource);
            that->gtk_shell1_destroy_resource(resource);

            that = resource->gtk_shell1_object;
            if (that && that->m_resource == resource)
                that->m_resource = nullptr;
        }
        delete resource;
    }

    gtk_shell1::Resource *gtk_shell1::bind(struct ::wl_client *client, uint32_t id, int version)
    {
        Q_ASSERT_X(!wl_client_get_object(client, id), "QWaylandObject bind", QStringLiteral("binding to object %1 more than once").arg(id).toLocal8Bit().constData());
        struct ::wl_resource *handle = wl_resource_create(client, &::gtk_shell1_interface, version, id);
        return bind(handle);
    }

    gtk_shell1::Resource *gtk_shell1::bind(struct ::wl_resource *handle)
    {
        Resource *resource = gtk_shell1_allocate();
        resource->gtk_shell1_object = this;

        wl_resource_set_implementation(handle, &m_gtk_shell1_interface, resource, destroy_func);
        resource->handle = handle;
        gtk_shell1_bind_resource(resource);
        return resource;
    }
    gtk_shell1::Resource *gtk_shell1::Resource::fromResource(struct ::wl_resource *resource)
    {
        if (Q_UNLIKELY(!resource))
            return nullptr;
        if (wl_resource_instance_of(resource, &::gtk_shell1_interface, &m_gtk_shell1_interface))
            return static_cast<Resource *>(wl_resource_get_user_data(resource));
        return nullptr;
    }

    const struct ::gtk_shell1_interface gtk_shell1::m_gtk_shell1_interface = {
        gtk_shell1::handle_get_gtk_surface,
        gtk_shell1::handle_set_startup_id,
        gtk_shell1::handle_system_bell,
        gtk_shell1::handle_notify_launch
    };

    void gtk_shell1::gtk_shell1_get_gtk_surface(Resource *, uint32_t, struct ::wl_resource *)
    {
    }

    void gtk_shell1::gtk_shell1_set_startup_id(Resource *, const QString &)
    {
    }

    void gtk_shell1::gtk_shell1_system_bell(Resource *, struct ::wl_resource *)
    {
    }

    void gtk_shell1::gtk_shell1_notify_launch(Resource *, const QString &)
    {
    }


    void gtk_shell1::handle_get_gtk_surface(
        ::wl_client *client,
        struct wl_resource *resource,
        uint32_t gtk_surface,
        struct ::wl_resource *surface)
    {
        Q_UNUSED(client);
        Resource *r = Resource::fromResource(resource);
        if (Q_UNLIKELY(!r->gtk_shell1_object)) {
            return;
        }
        static_cast<gtk_shell1 *>(r->gtk_shell1_object)->gtk_shell1_get_gtk_surface(
            r,
            gtk_surface,
            surface);
    }

    void gtk_shell1::handle_set_startup_id(
        ::wl_client *client,
        struct wl_resource *resource,
        const char *startup_id)
    {
        Q_UNUSED(client);
        Resource *r = Resource::fromResource(resource);
        if (Q_UNLIKELY(!r->gtk_shell1_object)) {
            return;
        }
        static_cast<gtk_shell1 *>(r->gtk_shell1_object)->gtk_shell1_set_startup_id(
            r,
            QString::fromUtf8(startup_id));
    }

    void gtk_shell1::handle_system_bell(
        ::wl_client *client,
        struct wl_resource *resource,
        struct ::wl_resource *surface)
    {
        Q_UNUSED(client);
        Resource *r = Resource::fromResource(resource);
        if (Q_UNLIKELY(!r->gtk_shell1_object)) {
            return;
        }
        static_cast<gtk_shell1 *>(r->gtk_shell1_object)->gtk_shell1_system_bell(
            r,
            surface);
    }

    void gtk_shell1::handle_notify_launch(
        ::wl_client *client,
        struct wl_resource *resource,
        const char *startup_id)
    {
        Q_UNUSED(client);
        Resource *r = Resource::fromResource(resource);
        if (Q_UNLIKELY(!r->gtk_shell1_object)) {
            return;
        }
        static_cast<gtk_shell1 *>(r->gtk_shell1_object)->gtk_shell1_notify_launch(
            r,
            QString::fromUtf8(startup_id));
    }

    void gtk_shell1::send_capabilities(uint32_t capabilities)
    {
        Q_ASSERT_X(m_resource, "gtk_shell1::capabilities", "Uninitialised resource");
        if (Q_UNLIKELY(!m_resource)) {
            qWarning("could not call gtk_shell1::capabilities as it's not initialised");
            return;
        }
        send_capabilities(
            m_resource->handle,
            capabilities);
    }

    void gtk_shell1::send_capabilities(struct ::wl_resource *resource, uint32_t capabilities)
    {
        gtk_shell1_send_capabilities(
            resource,
            capabilities);
    }


    gtk_surface1::gtk_surface1(struct ::wl_client *client, uint32_t id, int version)
        : m_resource_map()
        , m_resource(nullptr)
        , m_global(nullptr)
    {
        init(client, id, version);
    }

    gtk_surface1::gtk_surface1(struct ::wl_display *display, int version)
        : m_resource_map()
        , m_resource(nullptr)
        , m_global(nullptr)
    {
        init(display, version);
    }

    gtk_surface1::gtk_surface1(struct ::wl_resource *resource)
        : m_resource_map()
        , m_resource(nullptr)
        , m_global(nullptr)
    {
        init(resource);
    }

    gtk_surface1::gtk_surface1()
        : m_resource_map()
        , m_resource(nullptr)
        , m_global(nullptr)
    {
    }

    gtk_surface1::~gtk_surface1()
    {
        for (auto resource : std::as_const(m_resource_map))
            resource->gtk_surface1_object = nullptr;

        if (m_resource)
            m_resource->gtk_surface1_object = nullptr;

        if (m_global) {
            wl_global_destroy(m_global);
            wl_list_remove(&m_displayDestroyedListener.link);
        }
    }

    void gtk_surface1::init(struct ::wl_client *client, uint32_t id, int version)
    {
        m_resource = bind(client, id, version);
    }

    void gtk_surface1::init(struct ::wl_resource *resource)
    {
        m_resource = bind(resource);
    }

    gtk_surface1::Resource *gtk_surface1::add(struct ::wl_client *client, int version)
    {
        Resource *resource = bind(client, 0, version);
        m_resource_map.insert(client, resource);
        return resource;
    }

    gtk_surface1::Resource *gtk_surface1::add(struct ::wl_client *client, uint32_t id, int version)
    {
        Resource *resource = bind(client, id, version);
        m_resource_map.insert(client, resource);
        return resource;
    }

    void gtk_surface1::init(struct ::wl_display *display, int version)
    {
        m_global = wl_global_create(display, &::gtk_surface1_interface, version, this, bind_func);
        m_displayDestroyedListener.notify = gtk_surface1::display_destroy_func;
        m_displayDestroyedListener.parent = this;
        wl_display_add_destroy_listener(display, &m_displayDestroyedListener);
    }

    const struct wl_interface *gtk_surface1::interface()
    {
        return &::gtk_surface1_interface;
    }

    gtk_surface1::Resource *gtk_surface1::gtk_surface1_allocate()
    {
        return new Resource;
    }

    void gtk_surface1::gtk_surface1_bind_resource(Resource *)
    {
    }

    void gtk_surface1::gtk_surface1_destroy_resource(Resource *)
    {
    }

    void gtk_surface1::bind_func(struct ::wl_client *client, void *data, uint32_t version, uint32_t id)
    {
        gtk_surface1 *that = static_cast<gtk_surface1 *>(data);
        that->add(client, id, version);
    }

    void gtk_surface1::display_destroy_func(struct ::wl_listener *listener, void *data)
    {
        Q_UNUSED(data);
        gtk_surface1 *that = static_cast<gtk_surface1::DisplayDestroyedListener *>(listener)->parent;
        that->m_global = nullptr;
    }

    void gtk_surface1::destroy_func(struct ::wl_resource *client_resource)
    {
        Resource *resource = Resource::fromResource(client_resource);
        Q_ASSERT(resource);
        gtk_surface1 *that = resource->gtk_surface1_object;
        if (Q_LIKELY(that)) {
            that->m_resource_map.remove(resource->client(), resource);
            that->gtk_surface1_destroy_resource(resource);

            that = resource->gtk_surface1_object;
            if (that && that->m_resource == resource)
                that->m_resource = nullptr;
        }
        delete resource;
    }

    gtk_surface1::Resource *gtk_surface1::bind(struct ::wl_client *client, uint32_t id, int version)
    {
        Q_ASSERT_X(!wl_client_get_object(client, id), "QWaylandObject bind", QStringLiteral("binding to object %1 more than once").arg(id).toLocal8Bit().constData());
        struct ::wl_resource *handle = wl_resource_create(client, &::gtk_surface1_interface, version, id);
        return bind(handle);
    }

    gtk_surface1::Resource *gtk_surface1::bind(struct ::wl_resource *handle)
    {
        Resource *resource = gtk_surface1_allocate();
        resource->gtk_surface1_object = this;

        wl_resource_set_implementation(handle, &m_gtk_surface1_interface, resource, destroy_func);
        resource->handle = handle;
        gtk_surface1_bind_resource(resource);
        return resource;
    }
    gtk_surface1::Resource *gtk_surface1::Resource::fromResource(struct ::wl_resource *resource)
    {
        if (Q_UNLIKELY(!resource))
            return nullptr;
        if (wl_resource_instance_of(resource, &::gtk_surface1_interface, &m_gtk_surface1_interface))
            return static_cast<Resource *>(wl_resource_get_user_data(resource));
        return nullptr;
    }

    const struct ::gtk_surface1_interface gtk_surface1::m_gtk_surface1_interface = {
        gtk_surface1::handle_set_dbus_properties,
        gtk_surface1::handle_set_modal,
        gtk_surface1::handle_unset_modal,
        gtk_surface1::handle_present,
        gtk_surface1::handle_request_focus,
        gtk_surface1::handle_release,
        gtk_surface1::handle_titlebar_gesture
    };

    void gtk_surface1::gtk_surface1_set_dbus_properties(Resource *, const QString &, const QString &, const QString &, const QString &, const QString &, const QString &)
    {
    }

    void gtk_surface1::gtk_surface1_set_modal(Resource *)
    {
    }

    void gtk_surface1::gtk_surface1_unset_modal(Resource *)
    {
    }

    void gtk_surface1::gtk_surface1_present(Resource *, uint32_t )
    {
    }

    void gtk_surface1::gtk_surface1_request_focus(Resource *, const QString &)
    {
    }

    void gtk_surface1::gtk_surface1_release(Resource *)
    {
    }

    void gtk_surface1::gtk_surface1_titlebar_gesture(Resource *, uint32_t , struct ::wl_resource *, uint32_t )
    {
    }


    void gtk_surface1::handle_set_dbus_properties(
        ::wl_client *client,
        struct wl_resource *resource,
        const char *application_id,
        const char *app_menu_path,
        const char *menubar_path,
        const char *window_object_path,
        const char *application_object_path,
        const char *unique_bus_name)
    {
        Q_UNUSED(client);
        Resource *r = Resource::fromResource(resource);
        if (Q_UNLIKELY(!r->gtk_surface1_object)) {
            return;
        }
        static_cast<gtk_surface1 *>(r->gtk_surface1_object)->gtk_surface1_set_dbus_properties(
            r,
            QString::fromUtf8(application_id),
            QString::fromUtf8(app_menu_path),
            QString::fromUtf8(menubar_path),
            QString::fromUtf8(window_object_path),
            QString::fromUtf8(application_object_path),
            QString::fromUtf8(unique_bus_name));
    }

    void gtk_surface1::handle_set_modal(
        ::wl_client *client,
        struct wl_resource *resource)
    {
        Q_UNUSED(client);
        Resource *r = Resource::fromResource(resource);
        if (Q_UNLIKELY(!r->gtk_surface1_object)) {
            return;
        }
        static_cast<gtk_surface1 *>(r->gtk_surface1_object)->gtk_surface1_set_modal(
            r);
    }

    void gtk_surface1::handle_unset_modal(
        ::wl_client *client,
        struct wl_resource *resource)
    {
        Q_UNUSED(client);
        Resource *r = Resource::fromResource(resource);
        if (Q_UNLIKELY(!r->gtk_surface1_object)) {
            return;
        }
        static_cast<gtk_surface1 *>(r->gtk_surface1_object)->gtk_surface1_unset_modal(
            r);
    }

    void gtk_surface1::handle_present(
        ::wl_client *client,
        struct wl_resource *resource,
        uint32_t time)
    {
        Q_UNUSED(client);
        Resource *r = Resource::fromResource(resource);
        if (Q_UNLIKELY(!r->gtk_surface1_object)) {
            return;
        }
        static_cast<gtk_surface1 *>(r->gtk_surface1_object)->gtk_surface1_present(
            r,
            time);
    }

    void gtk_surface1::handle_request_focus(
        ::wl_client *client,
        struct wl_resource *resource,
        const char *startup_id)
    {
        Q_UNUSED(client);
        Resource *r = Resource::fromResource(resource);
        if (Q_UNLIKELY(!r->gtk_surface1_object)) {
            return;
        }
        static_cast<gtk_surface1 *>(r->gtk_surface1_object)->gtk_surface1_request_focus(
            r,
            QString::fromUtf8(startup_id));
    }

    void gtk_surface1::handle_release(
        ::wl_client *client,
        struct wl_resource *resource)
    {
        Q_UNUSED(client);
        Resource *r = Resource::fromResource(resource);
        if (Q_UNLIKELY(!r->gtk_surface1_object)) {
            wl_resource_destroy(resource);
            return;
        }
        static_cast<gtk_surface1 *>(r->gtk_surface1_object)->gtk_surface1_release(
            r);
    }

    void gtk_surface1::handle_titlebar_gesture(
        ::wl_client *client,
        struct wl_resource *resource,
        uint32_t serial,
        struct ::wl_resource *seat,
        uint32_t gesture)
    {
        Q_UNUSED(client);
        Resource *r = Resource::fromResource(resource);
        if (Q_UNLIKELY(!r->gtk_surface1_object)) {
            return;
        }
        static_cast<gtk_surface1 *>(r->gtk_surface1_object)->gtk_surface1_titlebar_gesture(
            r,
            serial,
            seat,
            gesture);
    }

    void gtk_surface1::send_configure(const QByteArray &states)
    {
        Q_ASSERT_X(m_resource, "gtk_surface1::configure", "Uninitialised resource");
        if (Q_UNLIKELY(!m_resource)) {
            qWarning("could not call gtk_surface1::configure as it's not initialised");
            return;
        }
        send_configure(
            m_resource->handle,
            states);
    }

    void gtk_surface1::send_configure(struct ::wl_resource *resource, const QByteArray &states)
    {
        struct wl_array states_data;
        states_data.size = states.size();
        states_data.data = static_cast<void *>(const_cast<char *>(states.constData()));
        states_data.alloc = 0;

        gtk_surface1_send_configure(
            resource,
            &states_data);
    }


    void gtk_surface1::send_configure_edges(const QByteArray &constraints)
    {
        Q_ASSERT_X(m_resource, "gtk_surface1::configure_edges", "Uninitialised resource");
        if (Q_UNLIKELY(!m_resource)) {
            qWarning("could not call gtk_surface1::configure_edges as it's not initialised");
            return;
        }
        send_configure_edges(
            m_resource->handle,
            constraints);
    }

    void gtk_surface1::send_configure_edges(struct ::wl_resource *resource, const QByteArray &constraints)
    {
        struct wl_array constraints_data;
        constraints_data.size = constraints.size();
        constraints_data.data = static_cast<void *>(const_cast<char *>(constraints.constData()));
        constraints_data.alloc = 0;

        gtk_surface1_send_configure_edges(
            resource,
            &constraints_data);
    }

}

QT_WARNING_POP
QT_END_NAMESPACE
