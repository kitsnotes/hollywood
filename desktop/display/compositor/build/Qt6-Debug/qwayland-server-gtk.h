// This file was generated by qtwaylandscanner
// source file is gtk.xml

#ifndef QT_WAYLAND_SERVER_GTK
#define QT_WAYLAND_SERVER_GTK

#include "wayland-server-core.h"
#include "wayland-gtk-server-protocol.h"
#include <QByteArray>
#include <QMultiMap>
#include <QString>

#ifndef WAYLAND_VERSION_CHECK
#define WAYLAND_VERSION_CHECK(major, minor, micro) \
    ((WAYLAND_VERSION_MAJOR > (major)) || \
    (WAYLAND_VERSION_MAJOR == (major) && WAYLAND_VERSION_MINOR > (minor)) || \
    (WAYLAND_VERSION_MAJOR == (major) && WAYLAND_VERSION_MINOR == (minor) && WAYLAND_VERSION_MICRO >= (micro)))
#endif

QT_BEGIN_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
QT_WARNING_DISABLE_CLANG("-Wmissing-field-initializers")

namespace QtWaylandServer {
    class  gtk_shell1
    {
    public:
        gtk_shell1(struct ::wl_client *client, uint32_t id, int version);
        gtk_shell1(struct ::wl_display *display, int version);
        gtk_shell1(struct ::wl_resource *resource);
        gtk_shell1();

        virtual ~gtk_shell1();

        class Resource
        {
        public:
            Resource() : gtk_shell1_object(nullptr), handle(nullptr) {}
            virtual ~Resource() {}

            gtk_shell1 *gtk_shell1_object;
            gtk_shell1 *object() { return gtk_shell1_object; } 
            struct ::wl_resource *handle;

            struct ::wl_client *client() const { return wl_resource_get_client(handle); }
            int version() const { return wl_resource_get_version(handle); }

            static Resource *fromResource(struct ::wl_resource *resource);
        };

        void init(struct ::wl_client *client, uint32_t id, int version);
        void init(struct ::wl_display *display, int version);
        void init(struct ::wl_resource *resource);

        Resource *add(struct ::wl_client *client, int version);
        Resource *add(struct ::wl_client *client, uint32_t id, int version);
        Resource *add(struct wl_list *resource_list, struct ::wl_client *client, uint32_t id, int version);

        Resource *resource() { return m_resource; }
        const Resource *resource() const { return m_resource; }

        QMultiMap<struct ::wl_client*, Resource*> resourceMap() { return m_resource_map; }
        const QMultiMap<struct ::wl_client*, Resource*> resourceMap() const { return m_resource_map; }

        bool isGlobal() const { return m_global != nullptr; }
        bool isResource() const { return m_resource != nullptr; }

        static const struct ::wl_interface *interface();
        static QByteArray interfaceName() { return interface()->name; }
        static int interfaceVersion() { return interface()->version; }


        enum capability {
            capability_global_app_menu = 1,
            capability_global_menu_bar = 2,
            capability_desktop_icons = 3,
        };

        void send_capabilities(uint32_t capabilities);
        void send_capabilities(struct ::wl_resource *resource, uint32_t capabilities);

    protected:
        virtual Resource *gtk_shell1_allocate();

        virtual void gtk_shell1_bind_resource(Resource *resource);
        virtual void gtk_shell1_destroy_resource(Resource *resource);

        virtual void gtk_shell1_get_gtk_surface(Resource *resource, uint32_t gtk_surface, struct ::wl_resource *surface);
        virtual void gtk_shell1_set_startup_id(Resource *resource, const QString &startup_id);
        virtual void gtk_shell1_system_bell(Resource *resource, struct ::wl_resource *surface);
        virtual void gtk_shell1_notify_launch(Resource *resource, const QString &startup_id);

    private:
        static void bind_func(struct ::wl_client *client, void *data, uint32_t version, uint32_t id);
        static void destroy_func(struct ::wl_resource *client_resource);
        static void display_destroy_func(struct ::wl_listener *listener, void *data);

        Resource *bind(struct ::wl_client *client, uint32_t id, int version);
        Resource *bind(struct ::wl_resource *handle);

        static const struct ::gtk_shell1_interface m_gtk_shell1_interface;

        static void handle_get_gtk_surface(
            ::wl_client *client,
            struct wl_resource *resource,
            uint32_t gtk_surface,
            struct ::wl_resource *surface);
        static void handle_set_startup_id(
            ::wl_client *client,
            struct wl_resource *resource,
            const char *startup_id);
        static void handle_system_bell(
            ::wl_client *client,
            struct wl_resource *resource,
            struct ::wl_resource *surface);
        static void handle_notify_launch(
            ::wl_client *client,
            struct wl_resource *resource,
            const char *startup_id);

        QMultiMap<struct ::wl_client*, Resource*> m_resource_map;
        Resource *m_resource;
        struct ::wl_global *m_global;
        struct DisplayDestroyedListener : ::wl_listener {
            gtk_shell1 *parent;
        };
        DisplayDestroyedListener m_displayDestroyedListener;
    };

    class  gtk_surface1
    {
    public:
        gtk_surface1(struct ::wl_client *client, uint32_t id, int version);
        gtk_surface1(struct ::wl_display *display, int version);
        gtk_surface1(struct ::wl_resource *resource);
        gtk_surface1();

        virtual ~gtk_surface1();

        class Resource
        {
        public:
            Resource() : gtk_surface1_object(nullptr), handle(nullptr) {}
            virtual ~Resource() {}

            gtk_surface1 *gtk_surface1_object;
            gtk_surface1 *object() { return gtk_surface1_object; } 
            struct ::wl_resource *handle;

            struct ::wl_client *client() const { return wl_resource_get_client(handle); }
            int version() const { return wl_resource_get_version(handle); }

            static Resource *fromResource(struct ::wl_resource *resource);
        };

        void init(struct ::wl_client *client, uint32_t id, int version);
        void init(struct ::wl_display *display, int version);
        void init(struct ::wl_resource *resource);

        Resource *add(struct ::wl_client *client, int version);
        Resource *add(struct ::wl_client *client, uint32_t id, int version);
        Resource *add(struct wl_list *resource_list, struct ::wl_client *client, uint32_t id, int version);

        Resource *resource() { return m_resource; }
        const Resource *resource() const { return m_resource; }

        QMultiMap<struct ::wl_client*, Resource*> resourceMap() { return m_resource_map; }
        const QMultiMap<struct ::wl_client*, Resource*> resourceMap() const { return m_resource_map; }

        bool isGlobal() const { return m_global != nullptr; }
        bool isResource() const { return m_resource != nullptr; }

        static const struct ::wl_interface *interface();
        static QByteArray interfaceName() { return interface()->name; }
        static int interfaceVersion() { return interface()->version; }


        enum state {
            state_tiled = 1,
            state_tiled_top = 2,
            state_tiled_right = 3,
            state_tiled_bottom = 4,
            state_tiled_left = 5,
        };

        enum edge_constraint {
            edge_constraint_resizable_top = 1,
            edge_constraint_resizable_right = 2,
            edge_constraint_resizable_bottom = 3,
            edge_constraint_resizable_left = 4,
        };

        enum gesture {
            gesture_double_click = 1,
            gesture_right_click = 2,
            gesture_middle_click = 3,
        };

        enum error {
            error_invalid_gesture = 0,
        };

        void send_configure(const QByteArray &states);
        void send_configure(struct ::wl_resource *resource, const QByteArray &states);
        void send_configure_edges(const QByteArray &constraints);
        void send_configure_edges(struct ::wl_resource *resource, const QByteArray &constraints);

    protected:
        virtual Resource *gtk_surface1_allocate();

        virtual void gtk_surface1_bind_resource(Resource *resource);
        virtual void gtk_surface1_destroy_resource(Resource *resource);

        virtual void gtk_surface1_set_dbus_properties(Resource *resource, const QString &application_id, const QString &app_menu_path, const QString &menubar_path, const QString &window_object_path, const QString &application_object_path, const QString &unique_bus_name);
        virtual void gtk_surface1_set_modal(Resource *resource);
        virtual void gtk_surface1_unset_modal(Resource *resource);
        virtual void gtk_surface1_present(Resource *resource, uint32_t time);
        virtual void gtk_surface1_request_focus(Resource *resource, const QString &startup_id);
        virtual void gtk_surface1_release(Resource *resource);
        virtual void gtk_surface1_titlebar_gesture(Resource *resource, uint32_t serial, struct ::wl_resource *seat, uint32_t gesture);

    private:
        static void bind_func(struct ::wl_client *client, void *data, uint32_t version, uint32_t id);
        static void destroy_func(struct ::wl_resource *client_resource);
        static void display_destroy_func(struct ::wl_listener *listener, void *data);

        Resource *bind(struct ::wl_client *client, uint32_t id, int version);
        Resource *bind(struct ::wl_resource *handle);

        static const struct ::gtk_surface1_interface m_gtk_surface1_interface;

        static void handle_set_dbus_properties(
            ::wl_client *client,
            struct wl_resource *resource,
            const char *application_id,
            const char *app_menu_path,
            const char *menubar_path,
            const char *window_object_path,
            const char *application_object_path,
            const char *unique_bus_name);
        static void handle_set_modal(
            ::wl_client *client,
            struct wl_resource *resource);
        static void handle_unset_modal(
            ::wl_client *client,
            struct wl_resource *resource);
        static void handle_present(
            ::wl_client *client,
            struct wl_resource *resource,
            uint32_t time);
        static void handle_request_focus(
            ::wl_client *client,
            struct wl_resource *resource,
            const char *startup_id);
        static void handle_release(
            ::wl_client *client,
            struct wl_resource *resource);
        static void handle_titlebar_gesture(
            ::wl_client *client,
            struct wl_resource *resource,
            uint32_t serial,
            struct ::wl_resource *seat,
            uint32_t gesture);

        QMultiMap<struct ::wl_client*, Resource*> m_resource_map;
        Resource *m_resource;
        struct ::wl_global *m_global;
        struct DisplayDestroyedListener : ::wl_listener {
            gtk_surface1 *parent;
        };
        DisplayDestroyedListener m_displayDestroyedListener;
    };
}

QT_WARNING_POP
QT_END_NAMESPACE

#endif
